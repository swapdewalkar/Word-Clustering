URL:http://www.technewsworld.com/story/hardware/84393.html
TITLE:Cracking the Shell | Hardware | TechNewsWorld
META-KEYWORDS:Linux,Google
DATE:Mar 21, 2017 3:22 PM PT
DOC ID:174
CONTENT:If you've begun to tinker with your desktop Linux terminal, you may be ready to take a deeper dive.You're no longer put off by references to "terminal," "command line" or "shell," and you have a grasp of how files are organized. You can distinguish between a command, an option and an argument. You've begun navigating your system.Now what? File manipulation -- that is, allowing users to traverse the directory structure and interact with its contents -- lies at the heart of Linux. There is a sizable arsenal of tools at your disposal. With the "mkdir" command, you can make new directories. The program takes one argument, which is a path ending with the name of the directory to be created.$ mkdir new_directoryOne nice thing about "mkdir" is that should you specify a directory that already exists, it won't overwrite the original.Similarly, the "touch" command, taking a path to a file as an argument, can make new (empty) files.$ touch fileAs with "mkdir", "touch" does not harm existing files -- it merely updates the timestamp for its last access. This feature is very useful when making incremental backups, which only save files after a certain date, but "touch" is also great for making disposable files to practice on.Removing files, using "rm", is a simple task as well, but you should approach it with caution. Supplying a path as an argument for "rm" will remove that file -- but once you hit Enter, it's gone forever. You won't find it in the Trash.$ rm fileOn the one hand, "rm" can't remove directories, so a slip of the keyboard won't cost you dozens of files. On the other, if you do want to remove a directory, and supply the "-r" option, there is no safety net, and the program will delete every directory it contains.$ rm -r target_directoryIf you want to give yourself the same breathing room with directories as "rm" affords regular files, you can use "rmdir", which returns an error and performs no action when the path leads to non-directories.$ rmdir target_directoryTo see file contents directly in terminal output, you can run "cat" with the file given as an argument.$ cat /fileWhat's the advantage of using "cat" rather than a paging viewer like "less"? It works faster than "less", and you easily can return the contents of multiple files at once simply by adding more arguments.$ cat file1 file2Finally, you can edit files with a terminal text editor like "nano" or "vim". As with any other command, type in the name of your chosen editor with a path to the file and the terminal will bring up the contents in the editor interface. The "nano" editor is a good one to begin with if you're keen to start altering files, as it has usage instructions listed along the bottom.To make the most of these new commands in your discovery process, it helps to understand how the shell fits into the picture. Everything your computer runs must be in binary format, so when you type a command, how does the terminal know where the binary is?The shell maintains an environment variable, a user- or system-wide value associated with a keyword (the variable name), called "PATH," and "PATH" lists all the directories where the shell should look for a command.Every command, like everything in Linux, has a path, and if you want to know what it is, run the "which" command followed by the name of the command you want to find.$ which commandYou'll get the path right to the binary. Now try running "echo $PATH", which returns the value of the "PATH" variable.$ echo $PATHOdds are the directory containing the command you looked up with "which" was in there. This is why you don't have type out the path that "which" returns for every command you run.There's more to the shell than that, however. To fine-tune its behavior and keep its users organized, the shell -- for Linux, Bash -- maintains a few configuration files. The first is ".bash_profile" or simply ".profile", depending on your Linux distribution, and it tells Bash what to do when a user logs in.In most cases, it simply starts your graphical desktop, but you can tailor your startup process to your needs by adding normal terminal commands. If you decide to play around with this (or any other) Bash file, it's best to make a backup (with "cp"). The second file is ".bashrc".This is the heart and soul of Bash, as it sets your command shortcuts, known as "aliases," and other customized variables. If you want to create a shorthand for a longer command, you can add a line to this file containing the word "alias", a space, the shortcut, an equal sign, and the command you want the shortcut to run (in quotes).alias shortcut="command"The Bash shell's third configuration file is ".bash_history", which contains a list of commands you've previously run, usually trimmed to the last few hundred. You will probably find this to be a valuable resource, so get accustomed to consulting it.Last, but not least is ".bash_logout", which tells Bash what to do when you end your session. For most users, there's not much to see here -- but again, depending on your needs, you can have Bash run a normal command at logout.Here are a few more tips if I've whetted your appetite.Manual pages provide detailed explanations of all the commands available on your system. To learn how to consult a "man" page, you actually can run "man man" to get -- you guessed it -- a reference for the "man" command.$ man manIf you're not sure which man page to look in, by running "man" with the "-K" option and a keyword as an argument, you can search the text of all man pages simultaneously.$ man -K keywordThis gives you every mention of that keyword across all the documentation on your system.To locate a file you know is somewhere on your system, you can use "find". Run "find" with the following arguments: the name of the directory you wish to search in (recursively), the "-name" option (this, or a similar option, is required), and the exact filename.$ find directory -name filenameIf you're a bit fuzzy on the name, but know what it starts or ends with, you can put a "*" on the back or front of the name, respectively.$ find directory -name partial_filename*$ find directory -name *partial_filenameWith this base of knowledge, you have more than enough to go a long way on your own. If you've been holding off on venturing deeper into your system, now is the perfect time to take the leap.If you hit a wall, don't be afraid to look on Google, post to a user forum, or ask me about it. If you're worried that you'll break something, rest assured that you probably won't, and there's always a way to put it back together, even if you do.I'm excited about what you'll turn up. Happy hunting!Jonathan Terrasi has been an ECT News Network columnist since 2017. His main interests are computer security (particularly with the Linux desktop), encryption, and analysis of politics and current affairs. He is a full-time freelance writer and musician. His background includes providing technical commentaries and analyses in articles published by the Chicago Committee to Defend the Bill of Rights.